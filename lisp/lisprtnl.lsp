;;;; -*-Mode: LISP; Package:LISP; Base:10; Syntax:ISLISP -*-
;;;; Title:     lisptests.lsp
;;;; Author:    C. Jullien
;;;; License:   Simplified BSD license
;;;; CVS:       $Id: lisprtnl.lsp,v 1.3 2012-01-27 15:57:33 jullien Exp $

;;;
;;; Simplified BSD License
;;;
;;; Copyright (c) 1992-2012, Eligis
;;; All rights reserved.
;;;
;;; Redistribution and  use in  source and binary  forms, with  or without
;;; modification, are permitted provided that the following conditions are
;;; met:
;;;
;;; o Redistributions  of  source  code must  retain  the  above copyright
;;;   notice, this list of conditions and the following disclaimer.
;;; o Redistributions  in  binary form  must reproduce the above copyright
;;;   notice, this list of conditions and  the following disclaimer in the
;;;   documentation and/or other materials provided with the distribution.
;;; 
;;; THIS SOFTWARE  IS PROVIDED BY  THE COPYRIGHT HOLDERS  AND CONTRIBUTORS
;;; "AS  IS" AND  ANY EXPRESS  OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT
;;; LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;; A PARTICULAR PURPOSE  ARE DISCLAIMED. IN NO EVENT  SHALL THE COPYRIGHT
;;; HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;; SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL  DAMAGES (INCLUDING,  BUT  NOT
;;; LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE,
;;; DATA, OR PROFITS; OR BUSINESS  INTERRUPTION) HOWEVER CAUSED AND ON ANY
;;; THEORY OF  LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY,  OR TORT
;;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  IN ANY WAY OUT OF THE USE
;;; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;

;;;
;;; Generate automatic non-regression tests for OpenLisp.
;;;

(defconstant rat1+ 1/3)
(defconstant rat2+ 2/3)
(defconstant rat3+ 1/7)
(defconstant rat4+ 19/7)
(defconstant rat5+ 2/9)
(defconstant rat6+ 7/9)

(defconstant rat1- (- rat1+))
(defconstant rat2- (- rat2+))
(defconstant rat3- (- rat3+))
(defconstant rat4- (- rat4+))
(defconstant rat5- (- rat5+))
(defconstant rat6- (- rat6+))

(defconstant small1+ 413)
(defconstant small1- -413)
(defconstant small2+ 223)
(defconstant small2- -223)

(defconstant zero 0)

#+openlisp (defun getvalue (x) (if (numberp x) x (symbol-global x)))
#-openlisp (defun getvalue (x) (if (numberp x) x (symbol-value x)))

#+openlisp
(defun rationalp (x)
   nil)

#-openlisp
(defun bignump (x)
   (or (> x #x7fffffff) (< x #x-7fffffff)))

#-openlisp
(defun reciprocal (x)
   (/ 1 x))

#-openlisp
(defun quotient (x y)
   (/ x y))

#-openlisp
(defun div (x y)
   ;; We use floor for CLtL:
   ;; floor converts its argument by truncating toward negative infinity;
   ;; that is, the result is the largest integer that is not larger than the
   ;; argument.
   ;;
   ;; Which is like div for ISLISP:
   ;; div returns the greatest integer less than or equal to the quotient
   ;; of z1 and z2.
   (floor x y))

#-openlisp
(defun string-append (&rest l)
   (apply #'string-concat l))

#-openlisp
(defmacro defglobal (x val)
   `(defconstant ,x ,val))

#-openlisp
(defmacro dynamic-let (&rest l)
   `(let ,@l))

(defun lowercase (x)
   (if (numberp x)
       x
       (string-downcase x)))

(defglobal *header* (list
   ";;;; -*-Mode:LISP; Package:LISP; Base:10; Syntax:ISLISP -*-~%"
   ";;;; Title:     testrtnl.lsp~%"
   ";;;; Author:    C. Jullien~%"
   ";;;; License:   New BSD license~%"
   ";;;; CVS:       $" "Id" "$~%"
   "~%"
   ";;;~%"
   ";;; Auto-test for ISLISP rational.~%"
   ";;; (automatically generated by bignum/lisp/lisprtnl.lsp)~%"
   ";;;~%"
   "~%"
   "(progn~%"
   "       (if (not (featurep 'rational))~%"
   "           (error \"testrtnl.lsp: rational module is required~~%\"))~%"
   "~%"
   "       (defglobal rat1+ " (format nil "~a" rat1+) ")~%"
   "       (defglobal rat2+ " (format nil "~a" rat2+) ")~%"
   "       (defglobal rat3+ " (format nil "~a" rat3+) ")~%"
   "       (defglobal rat4+ " (format nil "~a" rat4+) ")~%"
   "       (defglobal rat5+ " (format nil "~a" rat5+) ")~%"
   "       (defglobal rat6+ " (format nil "~a" rat6+) ")~%"
   "~%"
   "       (defglobal rat1- (- rat1+))~%"
   "       (defglobal rat2- (- rat2+))~%"
   "       (defglobal rat3- (- rat3+))~%"
   "       (defglobal rat4- (- rat4+))~%"
   "       (defglobal rat5- (- rat5+))~%"
   "       (defglobal rat6- (- rat6+))~%"
   "~%"
   "       (defglobal small1+ 413)~%"
   "       (defglobal small1- -413)~%"
   "       (defglobal small2+ 223)~%"
   "       (defglobal small2- -223)~%"
   "~%"
   "       (defglobal zero 0)~%"
   "       (defglobal *epsilon* 1e-4)~%"
   "~%"
   "       t)~40tt~%"
   "~%"
   "(test-serie \"\")~40tnil~%"
   "(test-serie \"Rationals\")~40tnil~%"
   "(test-serie \"---------\")~40tnil~%"
))

(defun print-header (fn)
   (format t "~%(test-serie \"Rtnl - ~a\")~40t()~%~%"
           (string-downcase fn)))

(defun call1 (f x)
   (let ((res (funcall (symbol-function f) (getvalue x))))
        (when (and (integerp res)
                   (/= res 99999999)) ;; make isqrt result looks better
              (setf res (lowercase (format () "~a" res))))
        (format t "(~a ~a) ~40t~a~%"
                (lowercase f)
                (lowercase x)
                (lowercase res))))

(defun call2 (f x y)
   (let ((res (funcall (symbol-function f) (getvalue x) (getvalue y))))
        (when (integerp res)
              (setf res (lowercase (format () "~a" res))))
        (format t "(~a ~a ~a) ~40t~a~%"
                (lowercase f)
                (lowercase x)
                (lowercase y)
                (lowercase res))))

(defun call-logtest (x y)
   (format t "(logtest~%  #b~68,'0b~%  #b~68,'0b)~75t~a~%"
           x y (lowercase (logtest x y))))

(defun test-reader (x)
   (setq x (getvalue x))
   (dolist (fmt '("~d" "~@d"))
      (setq fmt (string-append fmt "~40t~a~%"))
      (format t (lowercase (format nil fmt x x)))))

(defun test-parser (x)
   (setq x (getvalue x))
;   (dolist (fmt '("~d" "~@d" "#x~x" "#o~o" "#b~b" "#3r~3r" "#36r~36r"))
   (dolist (fmt '("~d" "~@d"))
      (setq fmt (string-append "(parse-number \"" fmt "\")~40t~a~%"))
      (format t (lowercase (format nil fmt x x)))))

(defun call-format (fmt x)
   (cond
         ((member fmt '("~e" "~f" "~g") :test #'equal)
          (format t "(parse-number (format nil \"~a\" ~a))~40t~a~%"
                  fmt (lowercase x) (format nil "~1,5e" (getvalue x))))
         (t
          (format t "(format nil \"~a\" ~a) ~40t\"~a\"~%"
                  fmt
                  (lowercase x)
                  (lowercase (format nil fmt (getvalue x)))))))

(defun test-print-base (base x)
   (format t "(test-print-base ~a ~a)~40t\"~a\"~%"
             (lowercase x)
             base
             (lowercase (dynamic-let ((*print-base* base))
                                     (write-to-string (getvalue x))))))

(defun test-read-base (base x)
   (format t "(dynamic-let ((*read-base* ~a))~%" base)
   (format t "   (let ((s \"~a\")~%"
             (lowercase (dynamic-let ((*print-base* base))
                                     (write-to-string (getvalue x)))))
   (format t "         (n 0))~%")
   (format t "        (setq n (read-from-string s))~%")
   (format t "        (and (= n (parse-number s)) n)))~%")
   (format t "#.~a~%" (lowercase x)))

(defun test-read-base (base x)
   (format t "(test-read-base \"~a\" ~a)~40t#.~a~%"
             (lowercase (dynamic-let ((*print-base* base))
                                     (write-to-string (getvalue x))))
             base
             (lowercase x)))

(defun test-conversion (x)
#|
   (format t (lowercase (format nil "(convert \"~a\" <integer>)~40t~a~%"
                                (getvalue x) (getvalue x))))
|#
   (format t (lowercase (format nil "(convert \"~a\" <float>)~40t~a~%"
                                (getvalue x) (float (getvalue x)))))
   (format t (lowercase (format nil "(convert ~a <string>)~40t\"~a\"~%"
                                x (getvalue x))))
   t)

(defun test-float (x)
   (format t (lowercase (format nil "(float ~a)~40t~a~%"
                                (getvalue x) (float (getvalue x)))))
   t)

(defun add-test-print-base ()
   (format t "(defun test-print-base (n base)~%")
   (format t "   (dynamic-let ((*print-base* base))~%")
   (format t "           (write-to-string n)))~40t\test-print-base~%~%"))

(defun add-test-read-base ()
   (format t "(defun test-read-base (s base)~%")
   (format t "   (dynamic-let ((*read-base* base))~%")
   (format t "       (let ((n (read-from-string s)))~%")
   (format t "            (and (= n (parse-number s)) n))))~%")
   (format t "test-read-base~%~%"))

(defun test-logbitp (x)
   (setq x (getvalue x))
  (format t "(test-logbitp #x~a)~40t\"" (lowercase (format nil "~x" x)))
   (let ((l nil))
        (do ((i 0 (1+ i)))
            ((= i 70))
            (setf l (cons (logbitp i x) l)))
        (dolist (c l)
           (format t (if c "1" "0")))
        (format t "\"~%" x)))

(defun make-test ()
   (let ((args '(rat1+ rat2+ rat3+ rat4+ rat5+ rat6+ small1+
                 zero
                 rat1- rat2- rat3- rat4- rat5- rat6- small1-)))
        (dolist (line *header*)
           (format t line))
        ;; reader
        (print-header 'reader)
        (dolist (arg '(rat1+ rat1- rat5+ rat5-))
           (test-reader arg))
        ;; parser
        (print-header 'parse-number)
        (dolist (arg '(rat1+ rat1- rat5+ rat5-))
           (test-parser arg))
        ;; format
        (print-header 'format)
        (dolist (arg '(rat1+ rat1- rat5+ rat5-))
           (call-format "~s" arg)
           (call-format "~a" arg)
           (call-format "~20s" arg)
           (call-format "~20a" arg)
           (call-format "~20@s" arg)
           (call-format "~20@a" arg)
           (call-format "~f" arg)
           (call-format "~g" arg)
           (call-format "~e" arg)
#|
           (call-format "~x" arg)
           (call-format "~@d" arg)
           (call-format "~d" arg)
           (call-format "~o" arg)
           (call-format "~b" arg)
           (call-format "~3r" arg)
           (call-format "~36r" arg)
|#
           t)
        ;; *print-base*
        (print-header '*print-base*)
        (add-test-print-base)
        (dolist (arg '(rat5+ rat5-))
           (do ((base 2 (1+ base)))
               ((= base 37))
               (test-print-base base arg)))
        ;; *read-base*
        (print-header '*read-base*)
        (add-test-read-base)
        (dolist (arg '(rat5+ rat5-))
           (do ((base 2 (1+ base)))
               ((= base 37))
               (test-read-base base arg)))
        ;; tests
        (dolist (f '(integerp numberp rationalp floatp consp vectorp symbolp))
           (print-header f)
           (dolist (arg '(rat5+ rat5- small1-))
              (call1 f arg)))
        ;; convert
        (print-header 'convert)
        (dolist (arg args)
           (test-conversion arg))
        ;; float
        (print-header 'float)
        (dolist (arg args)
           (test-float arg))
        ;; basic math
        (dolist (f '(eq eql equal = /= > >= < <=))
           (print-header f)
           (call2 f 'rat1+ 'rat2+)
           (call2 f 'rat1+ 'rat1+)
           (call2 f 'rat1+ 'rat1-)
           (call2 f 'rat1+ 'rat2-)
           (call2 f 'rat1- 'zero)
           (call2 f 'rat1- 'rat2+)
           (call2 f 'rat1- 'rat1+)
           (call2 f 'rat1- 'rat1-)
           (call2 f 'rat1- 'rat2-)
           (call2 f 'rat1- 'zero)
           (call2 f 'rat5+ 'small1+)
           (call2 f 'rat5+ 'small1-)
           (call2 f 'rat5- 'small1+)
           (call2 f 'rat5- 'small1-)
           (call2 f 'small1+ 'rat5+)
           (call2 f 'small1+ 'rat5-)
           (call2 f 'small1- 'rat5+)
           (call2 f 'small1- 'rat5-)
           t)
        ;; basic math
        (dolist (f '(+ - * / quotient)) ;;  div rem mod))
           (print-header f)
           (call2 f 'rat5+ -17)
           (call2 f 'rat5+ 17)
           (call2 f 'rat5+ 72)
           (call2 f 'rat5+ -72)
           (call2 f 'rat5- -17)
           (call2 f 'rat5- 17)
           (call2 f 'rat5- 72)
           (call2 f 'rat5- -72)
           (call2 f 'zero 'rat5+)
           (call2 f 'zero 'rat5-)
           (call2 f 'rat5+ 'rat5+)
           (call2 f 'rat5+ 'rat5-)
           (call2 f 'rat5- 'rat5+)
           (call2 f 'rat5- 'rat5-)
           (call2 f 'rat5+ 'small1+)
           (call2 f 'rat5+ 'small1-)
           (call2 f 'rat5- 'small1+)
           (call2 f 'rat5- 'small1-)
           (call2 f 'small1+ 'rat5+)
           (call2 f 'small1+ 'rat5-)
           (call2 f 'small1- 'rat5+)
           (call2 f 'small1- 'rat5-)
           t)
        ;; reciprocal
        (dolist (f '(reciprocal))
           (print-header f)
           (dolist (arg '(rat5+ rat6+ rat5-))
              (call1 f arg)))
        ;; plusp, minusp and zerop
        (dolist (f '(plusp minusp zerop))
           (print-header f)
           (dolist (arg args)
              (call1 f arg)))
        ;; rounding & alt.
        (dolist (f '(ceiling floor truncate round))
           (print-header f)
           (dolist (arg args)
              (call1 f arg)))
        t))

(make-test)
