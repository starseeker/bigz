  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML>
<META NAME="GENERATOR" CONTENT="TtH 1.57">                                                     
<title><font size="+4">BigNum:  A Portable and <br> Efficient Package <br> for
Arbitrary-Precision <br> Arithmetic</font></title>
<H1 align=center><font size="+4">BigNum:  A Portable and <br> Efficient Package <br> for
Arbitrary-Precision <br> Arithmetic</font></H1>


<H3 align=center> B. Serpette  <a href="#tthFtNtAAB" name=tthFrefAAB>Institut National de Recherche
          en Informatique et Automatique, 78150, Rocquencourt, France.</a><br>
        J. Vuillemin <a href="#tthFtNtAAC" name=tthFrefAAC>Digital Equipment Corp., Paris Research Laboratory,
        85, Av. Victor Hugo.        92563 Rueil-Malmaison Cedex, France.</a> <br>
        J.C. Herv&#233;  <sup>\dagger</sup>  <br>
       </H3>  
<p>
                                  
<H2> Abstract</H2>
We describe a C package for arbitrary-precision integer
arithmetic that is portable, yet efficient. Making the package run fast
on a given computer involves re-writing a small
kernel of our package in native assembly language. 
We provide such assembly code for VAX, 68020 and NS instruction sets,
with good benchmarks. This package serves as a foundation for
two arithmetic packages written in higher level
languages LeLisp <a href="#tthFtNtAAD" name=tthFrefAAD><sup>3</sup></a> and Modula2+. The package is publicly available for
non-commercial uses.
This report will also appear in French as an INRIA report.
<p>
<p>
      <H2><A NAME="tth_sEc1">
1</A>&nbsp;&nbsp;Introduction</H2>
Developing an arbitrary-precision arithmetic package that is
both efficient and portable brings up two main problems:

<UL>
<p>
  
<li>If an arithmetic package is written in a  high-level language
(such as languages Modula2+, LeLisp , C,...), the compiled code
will typically be 4 to 10  
times slower than carefully hand-crafted machine code.
  
<li> Many important arithmetic computations run an order of magnitude
faster when all forms of storage allocation are removed
from the inner loop,
storing intermediate and final results exclusively in the memory area
used by input variables. Yet some advanced form of automatic
storage management and garbage collection must be part of any useful
arithmetic package; furthermore, the number allocator must blend well with
native storage allocation in the host language.
</UL>
<p>
To satisfy these conflicting requirements, we have organized our
software in two layers:

<OL type="1">
<p>
  
<li> A layer called <tt>Bn</tt>, in which every operation deals with unsigned
integers,  allocates no storage,
and returns results in place of the first
argument passed to the routine. 
  
<li> A layer called <tt>Bz</tt>, implemented on top of <tt>Bn</tt>,
which implements signed arithmetic operations and allocates
storage for the results, in a straightforward manner.
</OL>
<p>
 Any high-level language <font face="helvetica"> <i>L</i></font>
capable of interfacing directly with the
language C can do so directly with <tt>Bn</tt> and  <tt>Bz</tt>. When language
<font face="helvetica"> <i>L</i></font> possesses its own storage allocator (possibly
with garbage collection, as 
in LeLisp and Modula2+), it is best to rewrite directly 
in <font face="helvetica"> <i>L</i></font> the (small)
storage allocation code of the <tt>Bz</tt> package. In this way, 
allocating and freeing numbers is directly handled in <font face="helvetica"> <i>L</i></font>. 
 
<p>
For speed reasons, the package <tt>Bn</tt> itself is structured in two
layers: 

<UL>
<p>
 
<li> The kernel <tt>KerN</tt>, which contains code for the time-critical 
low-level operations.
 
<li> The rest of <tt>Bn</tt>, whose C code   calls  the kernel.
</UL>
<p>
The kernel <tt>KerN</tt> is written in 
C for portability and documentation,  
and can be compiled as such. However, to obtain a truly efficient
implementation on a given machine, <tt>KerN</tt> must be directly written
in assembly code, which we provide for VAX, 68020, and NS instruction sets.
<tt>KerN</tt> is small indeed: 325 to 475 lines of C code, and 500 to 700 lines
of VAX assembly code.
 
<p>
The non-kernel part of <tt>Bn</tt> is written in C and compiled directly.
The distinction between kernel and non-kernel operations is defined so 
that the time penalty
for running the mixture of assembly and C code, 
as opposed to pure assembly code, is
less than 20% on typical benchmarks. The knowledge of 
which procedures are
in <tt>KerN</tt> is only important for someone who attempts to port the
package on a new machine and who is not satisfied with the speed of the C
implementation.
 
<p>
Finally, we point out that <tt>Bn</tt> has proved to be a sound basis on
which to develop other specialized packages, such as rational,
polynomial or modular arithmetic. Having full control over the exact
storage representation of numbers is the key to truly fast
implementations of such extensions to the basic package.

<p>
Details on how to obtain this package are in appendix .

<p>
      <H2><A NAME="tth_sEc2">
2</A>&nbsp;&nbsp;Number representation</H2>
Using radix b positional notation, an integer N  <font face=symbol>Î</font
> <b>N</b> can be
written as:

<centEr><table border=0 align=center><tr><td>
<Table align=left><tr><td nowrap align=center>
 <tt>N</tt> = </td><td nowrap align=center>
<font size="-1"></font> <Br><font face=symbol size="+3">å<br></font>
<font size="-1">0  <font face=symbol>£</font
> i <font face=symbol> &lt; </font
> nl</font>&nbsp;<br></td><td nowrap>
n<sub>i</sub> <b>b</b><sup>i</sup> &nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub>].</td></Table>
</td></table></centEr>


In this equation:

<UL>
<p>
  
<li> <b>b</b><font face=symbol> &gt; </font
> 1 is the <em>base</em>.
  
<li> For all i, 0  <font face=symbol>£</font
> i <font face=symbol> &lt; </font
> nl, n<sub>i</sub> are the <em>digits</em>
  of N written in base <b>b</b>, such that n<sub>i</sub>  <font face=symbol>Î</font
> <b>B</b><sub>b</sub> = [0..<b>b</b>-1].
  
<li> The <em>length</em> nl of N is any integer greater than or
  equal to the number <font face=symbol>é</font
>log<sub>b</sub>(N+1) <font face=symbol>ù</font
> of significant
  digits of N written in base <b>b</b>.
</UL>
<p>
In the implementation, the base <b>b</b> is the largest power of two
(typically 16 or 32) such that a digit
fits in a memory word, and the  instruction set supports base <b>b</b>
unsigned extended arithmetic. The digit bit length is parameterized
in the global C constant 

<center>
<p>
<tt>BN_DIGIT_SIZE</tt> &nbsp;&nbsp; = &nbsp;&nbsp;log<sub>2</sub>(<b>b</b>).
</center>
<p>
In <tt>Bn</tt>, an integer <tt>N</tt> <font face=symbol>Î</font
> <b>N</b> is passed as a
pair <tt>(n,nl)</tt> where:

<OL type="1">
<p>
  
<li> <tt>n</tt> is a pointer inside an array of consecutive digits,
  
<li> <tt>nl</tt> is the number (length) of digits from <tt>n</tt> in base <b>b</b>.
</OL>
<p>
Thus, for 0  <font face=symbol>£</font
> i <font face=symbol> &lt; </font
> nl, n<sub>i</sub> is the content of memory location
n+i. We use below the notation:

<centEr><table border=0 align=center><tr><td>
<Table align=left><tr><td nowrap align=center>
 <tt>N</tt> = </td><td nowrap align=center>
<font size="-1"></font> <Br><font face=symbol size="+3">å<br></font>
<font size="-1">0  <font face=symbol>£</font
> i <font face=symbol> &lt; </font
> nl</font>&nbsp;<br></td><td nowrap>
n<sub>i</sub> <b>b</b><sup>i</sup> &nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt> &nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub>].</td></Table>
</td></table></centEr>


for the integer N.

<p>
 In <tt>Bz</tt>, an integer is passed as a  pointer to an array of
consecutive digits; the header of this array contains the size (number of
digits) of the array, and the sign of the  number, defined as:

<centEr><table border=0 align=center><tr><td>
<Table align=left><tr><td nowrap align=center>
sgn(z) &nbsp;&nbsp; = &nbsp;&nbsp;</td><td align=left><font face=symbol>
ì<br>ï<br>ï<br>í<br>
ï<br>ï<br>î
</font></td><td align=center>
 </td><td nowrap><TablE border=0 align=left><tr><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 -1  if  z<font face=symbol> &lt; </font
>0; </td></tabLe></TD></TR><TR><TD NOWRAP align="center" colspan=0><tabLe border=0><tr><td nowrap Align=center>
0  if  z = 0; </td></tabLe></TD></TR><TR><TD NOWRAP align="center" colspan=0><tabLe border=0><tr><td nowrap Align=center>
1  if  z<font face=symbol> &gt; </font
>0;</td></tabLe></TD></TR></TablE>
</td><td nowrap>  </td></Table>
</td></table></centEr>



<p>
The implementation defines the following C types:

<pre>
typedef unsigned short BigNumCarry; /* Either 0 or 1 */
typedef unsigned int   BigNumDigit; /* A single 32 bits digit */
typedef BigNumDigit *  BigNum;      /* Entity seen by the user */
typedef short          BigNumCmp;   /* = -1, 0, or 1 */
typedef short          Boolean;
</pre>
<p>
Note that for the 16 bit implementation, the type <tt>BigNumDigit</tt> must
be cast to a C <tt>unsigned short</tt>.

<p>
      <H2><A NAME="tth_sEc3">
3</A>&nbsp;&nbsp;In place operations: Bn</H2>
We classify the procedures in <tt>Bn</tt> according to their
underlying mathematical operations.

<p>
      <H3><A NAME="tth_sEc3.1">
3.1</A>&nbsp;&nbsp;Initialization</H3>

<p>
   <b>Procedure 1</b> <em>Initialization <tt> BnnInit</tt>:
<a NAME="Bnn+Init()31">
</a>

<UL>
<p>
 
<li> <b>C header</b>: 

<pre>
void BnnInit()
</pre>
<p>
 
<li> <b>Inputs</b>: none 
 
<li> <b>Output</b>: none
 
<li> <b>Side Effect</b>: initializes Bn.
</UL>
<p>
</em>
Note: <tt> BnnInit</tt>  <font face=symbol>Ï</font
>  <tt>KerN</tt>.

<p>

   <b>Procedure 2</b> <em>Closing <tt> BnnClose</tt>:
<a NAME="Bnn+Close()31">
</a>

<UL>
<p>
 
<li> <b>C header</b>: 

<pre>
void BnnClose()
</pre>
<p>
 
<li> <b>Inputs</b>: none 
 
<li> <b>Output</b>: none
 
<li> <b>Side Effect</b>: closes Bn.
</UL>
<p>
</em>
Note: <tt> BnnClose</tt>  <font face=symbol>Ï</font
>  <tt>KerN</tt>.

<p>
      <H3><A NAME="tth_sEc3.2">
3.2</A>&nbsp;&nbsp;Addition</H3>

<p>
   <b>Procedure 3</b> <em>Increment  <tt> BnnAddCarry</tt>:
<a NAME="Bnn+AddCarry(n,nl,c)32">
</a>

<UL>
<p>
 
<li> <b>C header</b>: 

<pre>
BigNumCarry BnnAddCarry(n, nl, c)
    BigNum n;
    unsigned nl;
    BigNumCarry c; 
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>   <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ], the integer to be incremented.
     
<li> <tt>c</tt>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>, the carry in.
   </OL>
<p>
 
<li> <b>Invariant</b>: 
<tt>N</tt>+<tt>c</tt> &nbsp;&nbsp; = &nbsp;&nbsp;S &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>nl-1</sub> s<sub>nl</sub> ].
 
<li> <b>Output</b>: the carry out s<sub>nl</sub>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>.
 
<li> <b>Side Effect</b>: the nl least significant digits of S are
stored back in memory locations n through n+nl-1 as a 
<b>side effect</b> on the first argument <tt>n</tt> of the procedure:

<centEr><table border=0 align=center><tr><td>
<Table align=left><tr><td nowrap align=center>
&nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>nl-1</sub> ] &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>.</td></Table>
</td></table></centEr>


</UL>
<p>
</em>
Note: <tt> BnnAddCarry</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; the output is 1 iff 
<tt>N</tt> <font face=symbol>º</font
> <b>b</b><sup>nl</sup>-1 and <tt>c</tt> = 1; <tt>nl</tt> can be equal to zero, in
which case the carry out has the same value as the carry in.

<p>
   <b>Procedure 4</b> <em>Addition  <tt> BnnAdd</tt>:
<a NAME="Bnn+Add(m,ml,n,nl,c)32">
</a>

<UL>
<p>
 
<li><b>C header:</b>

<pre>
BigNumCarry BnnAdd(m, ml, n, nl, c)
    BigNum m, n;
    unsigned ml, nl;
    BigNumCarry c; 
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>    <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,ml)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>ml-1</sub> ], the addend;
     
<li>  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ],
the augend, no longer than
the addend: nl  <font face=symbol>£</font
> ml.
     
<li> <tt>c</tt>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>, the carry in.
   </OL>
<p>
 
<li> <b>Invariant</b>: 
<tt>N</tt>+ <tt>M</tt>+ <tt>c</tt> &nbsp;&nbsp; = &nbsp;&nbsp;S &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; &nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub> s<sub>ml</sub> ].
 
<li> <b>Output</b>: the carry out s<sub>ml</sub>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>.
 
<li> <b>Side Effect</b>:
&nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub> ] &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp;<tt>(m,ml)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnAdd</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; it is possible to call <tt> BnnAdd</tt>
with <tt>m</tt> = <tt>n</tt>;
<tt>nl</tt> can be equal to zero, in
which case the operation <tt>BnnAdd</tt> is equivalent to 
<tt>BnnAddCarry(m, ml, c)</tt>.

<p>
      <H3><A NAME="tth_sEc3.3">
3.3</A>&nbsp;&nbsp;Subtraction</H3>

<p>
   <b>Procedure 5</b> <em>Additive Inverse   <tt> BnnComplement</tt>:
<a NAME="Bnn+Complement(n,nl)33">
</a>

<UL>
<p>
 
<li> <b>C header</b>:

<pre>
void BnnComplement(n, nl)
    BigNum n; 
    unsigned nl; 
</pre>
<p>
 
<li> <b>Input</b>: 
  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ].
 
<li> <b>Invariant</b>: <tt>N</tt>+[<font face=symbol>`</font
>N] = <b>b</b><sup>nl</sup>-1; &nbsp;&nbsp;[<font face=symbol>`</font
>N] &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[[<font face=symbol>`</font
>(n<sub>0</sub>)] <font face=symbol>¼</font
>[<font face=symbol>`</font
>(n<sub>nl-1</sub>)]], with [<font face=symbol>`</font
>(n<sub>k</sub>)] = <b>b</b>-n<sub>k</sub>-1.
 
<li> <b>Output</b>: none
 
<li> <b>Side Effect</b>: 

<p>
&nbsp;<sub>b</sub>[[<font face=symbol>`</font
>(n<sub>0</sub>)] <font face=symbol>¼</font
>[<font face=symbol>`</font
>(n<sub>nl-1</sub>)] ] &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp; <tt>(n,nl)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnComplement</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; does nothing when nl = 0.

<p>
   <b>Procedure 6</b> <em>Decrement  <tt> BnnSubtractBorrow</tt>:
<a NAME="Bnn+SubtractBorrow(n,nl,br)33">
</a>

<UL>
<p>
 
<li><b>C header:</b>

<pre>
BigNumCarry BnnSubtractBorrow(n, nl, br)
    BigNum n;
    unsigned nl;
    BigNumCarry br; 
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>   <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ], the integer to be decremented.
     
<li> <tt>br</tt>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>, the borrow in.
   </OL>
<p>
 
<li> <b>Invariant</b>: 
<tt>N</tt>+<b>b</b><sup>nl</sup>+<tt>br</tt>-1 &nbsp;&nbsp; = &nbsp;&nbsp;S &nbsp;&nbsp;  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>nl-1</sub> s<sub>nl</sub> ].
 
<li> <b>Output</b>: the borrow out s<sub>nl</sub>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>.
 
<li> <b>Side Effect</b>:
&nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>nl-1</sub> ] &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnSubtractBorrow</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; the output  is 0 iff
<tt>N</tt> = <tt>br</tt> = 0; <tt>nl</tt> can be equal to zero, in which case the carry out 
has the same value as the carry in.
 
<p>

   <b>Procedure 7</b> <em>Subtraction  <tt> BnnSubtract</tt>:
<a NAME="Bnn+Subtract(m,ml,n,nl,br)33">
</a>

<UL>
<p>
 
<li><b>C header:</b>

<pre>
BigNumCarry BnnSubtract(m, ml, n, nl, br)
    BigNum m, n;
    unsigned ml, nl;
    BigNumCarry br; 
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>    <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,ml)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>ml-1</sub> ], the positive term;
     
<li>  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ], 
the negative term, no longer than the positive: <tt>nl</tt>  <font face=symbol>£</font
> <tt>ml</tt>.
     
<li> <tt>br</tt>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>, the borrow in.
   </OL>
<p>
 
<li> <b>Invariant</b>: 
<tt>M</tt>+<b>b</b><sup>ml</sup>- <tt>N</tt>+<tt>br</tt>-1 &nbsp;&nbsp; = &nbsp;&nbsp;S &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; &nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub> s<sub>ml</sub> ].
 
<li> <b>Output</b>: the borrow out s<sub>ml</sub>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>.
 
<li> <b>Side Effect</b>:
&nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub> ] &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp;<tt>(m,ml)</tt>.
</UL>
<p>
</em>
Note:  <tt> BnnSubtract</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; the output s<sub>ml</sub> is 0 iff
<tt>N</tt>+<tt>br</tt>  <font face=symbol>£</font
> <tt>M</tt>; it is possible to call <tt> BnnSubtract</tt> with 
<tt>m</tt> = <tt>n</tt>; 
<tt>nl</tt> can be equal to zero, in
which case the operation <tt>BnnSubtract</tt> is equivalent to 
<tt>BnnSubtractBorrow(m, ml, br)</tt>.
 
<p>
      <H3><A NAME="tth_sEc3.4">
3.4</A>&nbsp;&nbsp;Multiplication</H3>

<p>
   <b>Procedure 8</b> <em>Multiplication by a digit  <tt> BnnMultiplyDigit</tt>:
<a NAME="Bnn+MultiplyDigit(p,pl,m,ml,d)34">
</a>

<UL>
<p>
 
<li><b>C header:</b>

<pre>
BigNumCarry BnnMultiplyDigit(p, pl, m, ml, d)
    BigNum p, m;
    unsigned pl, ml; 
    BigNumDigit d;
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>   <tt>P</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(p,pl)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[p<sub>0</sub> <font face=symbol>¼</font
>p<sub>pl-1</sub> ], the sum;
     
<li>   
<p>
 <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,ml)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>ml-1</sub> ], the multiplier, 
shorter than the sum: <tt>pl</tt><font face=symbol> &gt; </font
><tt>ml</tt>.
     
<li>  <tt>D</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; the multiplicand digit <tt>d</tt>.
   </OL>
<p>
 
<li> <b>Invariant</b>: 
<tt>P</tt>+ <tt>M</tt>&times;<tt>D</tt>&nbsp;&nbsp; = &nbsp;&nbsp;R &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; &nbsp;<sub>b</sub>[r<sub>0</sub> <font face=symbol>¼</font
>r<sub>pl-1</sub> r<sub>pl</sub> ].
 
<li> <b>Output</b>: the carry out r<sub>pl</sub>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>.
 
<li> <b>Side Effect</b>:
&nbsp;<sub>b</sub>[r<sub>0</sub> <font face=symbol>¼</font
>r<sub>pl-1</sub> ] &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp;<tt>(p,pl)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnMultiplyDigit</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; <tt>ml</tt> can be equal to
zero, in which case the carry out is zero and no side effect is performed;
it is possible to call <tt>BnnMultiplyDigit</tt> with
<tt>p</tt>  <font face=symbol>º</font
> <tt>m</tt>; 
the digit <tt>d</tt> can be any digit of <tt>P</tt>or <tt>M</tt>.
 
<p>

   <b>Procedure 9</b> <em>Long Multiplication  <tt> BnnMultiply</tt>:
<a NAME="Bnn+Multiply(p,pl,m,ml,n,nl)34">
</a>

<UL>
<p>
 
<li><b>C header:</b>

<pre>
BigNumCarry BnnMultiply (p, pl, m, ml, n, nl)
    BigNum p, m, n;
    unsigned pl, ml, nl;
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>   <tt>P</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(p,pl)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[p<sub>0</sub> <font face=symbol>¼</font
>p<sub>pl-1</sub> ], the sum;
     
<li>   
<p>
 <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,ml)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>ml-1</sub> ], the multiplier;
     
<li>  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ], 
the multiplicand.
   </OL>
<p>
The length of operands must be such that <tt>pl</tt> <font face=symbol>³</font
> <tt>nl</tt>+<tt>ml</tt>
and  <tt>ml</tt>  <font face=symbol>³</font
> <tt>nl</tt>; this last condition is imposed by
speed requirements.
 
<li> <b>Invariant</b>: 
<tt>P</tt>+ <tt>M</tt>&times;<tt>N</tt>&nbsp;&nbsp; = &nbsp;&nbsp;R &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; &nbsp;<sub>b</sub>[r<sub>0</sub> <font face=symbol>¼</font
>r<sub>pl-1</sub> r<sub>pl</sub> ].
 
<li> <b>Output</b>: the carry out r<sub>pl</sub>  <font face=symbol>Î</font
> <b>B</b><sub>2</sub>.
 
<li> <b>Side Effect</b>:
&nbsp;<sub>b</sub>[r<sub>0</sub> <font face=symbol>¼</font
>r<sub>pl-1</sub> ] &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp;<tt>(p,pl)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnMultiply</tt>  <font face=symbol>Ï</font
>  <tt>KerN</tt>;
it is possible to
call <tt>BnnMultiply</tt> with <tt>n</tt> = <tt>m</tt>; when <tt>nl</tt> = 0 there
is no side effect and the carry out is 0.

<p>
   <b>Procedure 10</b> <em>Multiply by a power of 2  <tt> BnnShiftLeft</tt>:
<a NAME="Bnn+ShiftLeft(m,ml,nbits)34">
</a>

<UL>
<p>
 
<li> <b>C header</b>:

<pre>
BigNumDigit BnnShiftLeft(m, ml, nbits)
    BigNum m; 
    unsigned ml, nbits;
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>    <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,ml)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>ml-1</sub> ], the integer to be shifted left.
     
<li> <tt>nbits</tt>  <font face=symbol>Î</font
> <b>N</b>, the shift amount, 0  <font face=symbol>£</font
> <tt>nbits</tt>
<font face=symbol> &lt; </font
> log<sub>2</sub>(<b>b</b>).
   </OL>
<p>
 
<li> <b>Invariant</b>: 
<tt>M</tt>&nbsp;&nbsp;&times;&nbsp;&nbsp;2<sup><tt>nbits</tt></sup> = &nbsp;&nbsp;S &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; &nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub> s<sub>ml</sub> ].
 
<li> <b>Output</b>: the digit  s<sub>ml</sub> shifted out.
 
<li> <b>Side Effects</b>:

<p>
 </td><td nowrap><TablE border=0 align=left><tr><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 &nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub> ] </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <font face=symbol>Þ</font
> </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <tt>(m,ml)</tt>.</td></tabLe></TD></TR></TablE>
</td><td nowrap>
</UL>
<p>
</em>
Note: <tt> BnnShiftLeft</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; if <tt>ml</tt> = 0 then s<sub>ml</sub> = 0.
 
<p>
      <H3><A NAME="tth_sEc3.5">
3.5</A>&nbsp;&nbsp;Division</H3>

<p>
   <b>Procedure 11</b> <em>Division by a digit  <tt> BnnDivideDigit</tt>:
<a NAME="Bnn+DivideDigit(q,n,nl,d)35">
</a>

<UL>
<p>
 
<li><b>C header:</b>

<pre>
BigNumDigit BnnDivideDigit(q, n, nl, d)
    BigNum q, n;
    unsigned nl; 
    BigNumDigit d;
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>   <tt>Q</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(q,nl-1)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[q<sub>0</sub> <font face=symbol>¼</font
>q<sub>nl-2</sub> ],.
     
<li>  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ], the dividend.
     
<li>  <tt>D</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; 
the divisor digit <tt>d</tt>, whose value must be greater than that of the most
significant digit of <tt>N</tt>: <tt>d</tt>  <font face=symbol> &gt; </font
> n<sub>nl-1</sub>.
   </OL>
<p>
 
<li> <b>Invariant</b>: <tt>N</tt> = <tt>D</tt>&times;<tt>Q</tt>+ <tt>R</tt>, &nbsp;&nbsp;0  <font face=symbol>£</font
> <tt>R</tt><font face=symbol> &lt; </font
> <tt>D</tt>,
with  <tt>Q</tt> <font face=symbol>º</font
> &nbsp;<sub>b</sub>[q<sub>0</sub> <font face=symbol>¼</font
>q<sub>nl-2</sub>] , &nbsp;&nbsp;<tt>R</tt> <font face=symbol>º</font
> &nbsp;<sub>b</sub>[r<sub>0</sub> ].
 
<li> <b>Output</b>: the remaining digit R.
 
<li> <b>Side Effect</b>: 
 </td><td nowrap><TablE border=0 align=left><tr><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 &nbsp;<sub>b</sub>[q<sub>0</sub> <font face=symbol>¼</font
>q<sub>nl-2</sub>] </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <font face=symbol>Þ</font
> </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <tt>(q,nl-1)</tt>.</td></tabLe></TD></TR></TablE>
</td><td nowrap> 
</UL>
<p>
</em>
Note: <tt> BnnDivideDigit</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt> stores the <tt>nl</tt>-1 
digits of the quotient  in <tt>Q</tt> and returns the remainder.
 
<p>

   <b>Procedure 12</b> <em>Long Division  <tt> BnnDivide</tt>:
<a NAME="Bnn+Divide(n,nl,d,dl)35">
</a>

<UL>
<p>
 
<li><b>C header:</b>

<pre>
void BnnDivide (n, nl, d, dl)
    BigNum n, d;
    unsigned nl, dl;
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>   <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ], the dividend.
     
<li>  <tt>D</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(d,dl)</tt>, 
the divisor, shorter than the dividend:  <tt>dl</tt><font face=symbol> &lt; </font
><tt>nl</tt>.
   </OL>
<p>
The most significant digit of the divisor must be greater than that of 
the dividend: 
<centEr><table border=0 align=center><tr><td>
<Table align=left><tr><td nowrap align=center>
d<sub>dl-1</sub> <font face=symbol> &gt; </font
> n<sub>nl-1</sub>.</td></Table>
</td></table></centEr>


Without this condition, we could not guarantee that both quotient and
remainder will exactly fit in the storage allocated to <tt>N</tt>.
 
<li> <b>Invariant</b>: <tt>N</tt> = <tt>D</tt>&times;<tt>Q</tt>+ <tt>R</tt>, &nbsp;&nbsp;0  <font face=symbol>£</font
> <tt>R</tt><font face=symbol> &lt; </font
> <tt>D</tt>, with

<p>
 <tt>Q</tt> <font face=symbol>º</font
> &nbsp;<sub>b</sub>[q<sub>0</sub> <font face=symbol>¼</font
>q<sub>nl-dl-1</sub>] , &nbsp;&nbsp;<tt>R</tt> <font face=symbol>º</font
> &nbsp;<sub>b</sub>[r<sub>0</sub> <font face=symbol>¼</font
>r<sub>dl-1</sub> ].
 
<li> <b>Output</b>: none
 
<li> <b>Side Effect</b>:

<p>
 </td><td nowrap><TablE border=0 align=left><tr><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 &nbsp;<sub>b</sub>[r<sub>0</sub> <font face=symbol>¼</font
>r<sub>dl-1</sub>] </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <font face=symbol>Þ</font
> </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <tt>(n,dl)</tt>; </td></tabLe></TD></TR><TR><TD NOWRAP align="center" colspan=0><tabLe border=0><tr><td nowrap Align=center>
 &nbsp;<sub>b</sub>[q<sub>0</sub> <font face=symbol>¼</font
>q<sub>nl-dl-1</sub>] </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <font face=symbol>Þ</font
> </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <tt>(n+dl,nl-dl)</tt>.</td></tabLe></TD></TR></TablE>
</td><td nowrap> 
</UL>
<p>
</em>
Note: <tt> BnnDivide</tt>  <font face=symbol>Ï</font
>  <tt>KerN</tt>, replaces the nl-dl most
significant digits of <tt>N</tt> by the quotient, and the dl least significant
digits by the remainder.

<p>
   <b>Procedure 13</b> <em>Divide by a power of 2  <tt> BnnShiftRight</tt>:
<a NAME="Bnn+ShiftRight(m,ml,nbits)35">
</a>

<UL>
<p>
 
<li> <b>C header</b>:

<pre>
BigNumDigit BnnShiftRight(m, ml, nbits)
    BigNum m;
    unsigned ml, nbits;
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>    <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,ml)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>ml-1</sub> ], the integer to be shifted right.
     
<li> <tt>nbits</tt>  <font face=symbol>Î</font
> <b>N</b>, the shift amount, 0  <font face=symbol>£</font
> <tt>nbits</tt>
<font face=symbol> &lt; </font
> log<sub>2</sub>(<b>b</b>).
   </OL>
<p>
 
<li> <b>Invariant</b>:  
    
<p>
<tt>M</tt>&nbsp;&nbsp; = &nbsp;&nbsp;2<sup><tt>nbits</tt></sup> &times;S + R &times; 2<sup><tt>nbits</tt>-BN_DIGIT_SIZE</sup> &nbsp;&nbsp; = &nbsp;&nbsp;2<sup><tt>nbits</tt></sup> &times;(S + R &times;<b>b</b><sup>-1</sup>)
with S &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub>], 0  <font face=symbol>£</font
> R <font face=symbol> &lt; </font
> <b>b</b>. 
 
<li> <b>Output</b>: the shifted out digit R.
 
<li> <b>Side Effect</b>:

<p>
 </td><td nowrap><TablE border=0 align=left><tr><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 &nbsp;<sub>b</sub>[s<sub>0</sub> <font face=symbol>¼</font
>s<sub>ml-1</sub> ] &nbsp;&nbsp;</td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 <font face=symbol>Þ</font
> </td></tabLe></td><td nowrap align=center>
<tabLe border=0><tr><td nowrap Align=center>
 &nbsp;&nbsp;<tt>(m,ml)</tt></td></tabLe></TD></TR></TablE>
</td><td nowrap>.
</UL>
<p>
</em>
Note:  <tt> BnnShiftRight</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; if <tt>ml</tt> = 0
then R = 0.
 
<p>
 The next two procedures are used in the normalization step of long
division.

<p>
   <b>Procedure 14</b> <em><tt> BnnNumLeadingZeroBitsInDigit</tt>:
<a NAME="Bnn+NumLeadingZeroBitsInDigit(d)35">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
unsigned BnnNumLeadingZeroBitsInDigit(d) 
    BigNumDigit d; 
</pre>
<p>
  
<li><b>Input</b>: digit <tt>d</tt>.
  
<li><b>Invariant</b>:  [(<b>b</b>)/ 2] <font face=symbol> &lt; </font
> 2<sup>k</sup> &times;(<tt>d</tt>+1)  <font face=symbol>£</font
> <b>b</b>.
  
<li><b>Output</b>: k.
  
<li><b>Side Effect</b>: none
</UL>
<p>
</em>
Note:       <tt> BnnNumLeadingZeroBitsInDigit </tt>  <font face=symbol>Î</font
>   <tt>KerN</tt>.
The output is the number of most significant bits equal to zero in <tt>d</tt>.

<p>
   <b>Procedure 15</b> <em><tt> BnnIsDigitNormalized </tt>:
<a NAME="Bnn+IsDigitNormalized(d)35">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
Boolean BnnIsDigitNormalized(d) 
    BigNumDigit d; 
</pre>
<p>
  
<li><b>Input</b>: digit <tt>d</tt>.
  
<li><b>Output</b>: the predicate [(<b>b</b>)/ 2]  <font face=symbol>£</font
> <tt>d</tt> <font face=symbol> &lt; </font
> <b>b</b>.
  
<li><b>Side Effect</b>: none.
</UL>
<p>
</em>
Note: <tt> BnnIsDigitNormalized </tt>   <font face=symbol>Î</font
>   <tt>KerN</tt>.
 
<p>
      <H3><A NAME="tth_sEc3.6">
3.6</A>&nbsp;&nbsp;Comparisons</H3>

<p>
   <b>Procedure 16</b> <em>Test for zero digit    <tt> BnnIsDigitZero</tt>:
<a NAME="Bnn+IsDigitZero(d)36">
</a>

<UL>
<p>
 
<li> <b>C header</b>:

<pre>
Boolean BnnIsDigitZero(d) 
    BigNumDigit d; 
</pre>
<p>
 
<li> <b>Input</b>: digit <tt>d</tt>.
 
<li> <b>Output</b>: the predicate (<tt>d</tt> = 0).
 
<li> <b>Side Effect</b>: none
</UL>
<p>
</em>
Note: <tt> BnnIsDigitZero</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>. 
 
<p>

   <b>Procedure 17</b> <em>Test for zero number   <tt> BnnIsZero</tt>:
<a NAME="Bnn+IsZero(n,nl)36">
</a>

<UL>
<p>
 
<li> <b>C header</b>:

<pre>
Boolean BnnIsZero (n, nl)
    BigNum n;
    unsigned nl;
</pre>
<p>
 
<li> <b>Input</b>: 
  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ].
 
<li> <b>Output</b>: the predicate (<tt>N</tt> = 0).
 
<li> <b>Side Effect</b>: none
</UL>
<p>
</em>
Note: <tt> BnnIsZero</tt>  <font face=symbol>Ï</font
>  <tt>KerN</tt>. 

<p>
   <b>Procedure 18</b> <em>Digit comparison  <tt> BnnCompareDigits</tt>:
<a NAME="Bnn+CompareDigits(c,d)36">
</a>

<UL>
<p>
 
<li> <b>C header</b>:

<pre>
BigNumCmp BnnCompareDigits(c, d)
    BigNumDigit c, d;
</pre>
<p>
 
<li> <b>Inputs</b>: digits <tt>c</tt> and <tt>d</tt>.
 
<li> <b>Output</b>: sgn(<tt>c</tt> - <tt>d</tt>) = { -1,0,1 }.
 
<li> <b>Side Effect</b>: none
</UL>
<p>
</em>
Note: <tt> BnnCompareDigits</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>.

<p>
   <b>Procedure 19</b> <em>Number comparison  <tt> BnnCompare</tt>:
<a NAME="Bnn+Compare(m,ml,n,nl)36">
</a>

<UL>
<p>
 
<li> <b>C header</b>:

<pre>
BigNumCmp BnnCompare (m, ml, n, nl)
    BigNum m, n;
    unsigned ml, nl;
</pre>
<p>
 
<li> <b>Inputs</b>: 
   
<OL type="1">
<p>
     
<li>  <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,ml)</tt> &nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>ml-1</sub> ].
     
<li>  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ].
   </OL>
<p>
 
<li> <b>Output</b>: sgn(<tt>M</tt>- <tt>N</tt>) = { -1,0,1 }.
 
<li> <b>Side Effect</b>: none
</UL>
<p>
</em>
Note: <tt> BnnCompare</tt>  <font face=symbol>Ï</font
>  <tt>KerN</tt>.

<p>
   <b>Procedure 20</b> <em><tt> BnnIsDigitOdd </tt>:
<a NAME="Bnn+IsDigitOdd(d)36">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
Boolean BnnIsDigitOdd(d) 
    BigNumDigit d; 
</pre>
<p>
  
<li><b>Input</b>: digit <tt>d</tt>.
  
<li><b>Output</b>: the predicate (<tt>d</tt>  mod 2 = 1).
  
<li><b>Side Effect</b>: none.
</UL>
<p>
</em>
Note:  <tt> BnnIsDigitOdd</tt>  <font face=symbol>Ï</font
>  <tt>KerN</tt>. 

<p>
   <b>Procedure 21</b> <em><tt> BnnNumDigits </tt>:
<a NAME="Bnn+NumDigits(n,nl)36">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
unsigned BnnNumDigits(n, nl)  
    BigNum n;  
    unsigned nl; 
</pre>
<p>
  
<li><b>Input</b>:
    <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>.
  
<li><b>Invariant</b>: 
 ln = <font face=symbol>é</font
>log<sub><b>b</b></sub>(<tt>N</tt>+1 ) <font face=symbol>ù</font
>,&nbsp;&nbsp;if&nbsp;&nbsp; <tt>N</tt> <font face=symbol>¹</font
> 0&nbsp;&nbsp;and&nbsp;&nbsp;1&nbsp;&nbsp;otherwise.
  
<li><b>Output</b>: ln.
  
<li><b>Side Effect</b>: none.
</UL>
<p>
</em>
Note:  <tt> BnnNumDigits</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; ln is the number of
significant digits of <tt>N</tt>.
 
<p>
      <H3><A NAME="tth_sEc3.7">
3.7</A>&nbsp;&nbsp;Logical operations</H3>

<p>
   <b>Procedure 22</b> <em><tt> BnnAndDigits </tt>:
<a NAME="Bnn+AndDigits(n,d)37">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
void BnnAndDigits(n, d) 
    BigNum n; 
    BigNumDigit d;
</pre>
<p>
  
<li><b>Inputs</b>
   
<OL type="1">
<p>
    
<li>     <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; <tt>(n,1)</tt>.
    
<li>     <tt>D</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; digit <tt>d</tt>.
   </OL>
<p>
  
<li><b>Invariant</b>: let n&d be the bitwise logical <em>AND</em> 
of <tt>N</tt> and
D.
  
<li><b>Output</b>: none
  
<li><b>Side Effect</b>: n&d &nbsp;&nbsp;<font face=symbol>Þ</font
> <tt>(n,1)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnAndDigits</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>. 

<p>
   <b>Procedure 23</b> <em><tt> BnnOrDigits </tt>:
<a NAME="Bnn+OrDigits(n,d)37">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
void BnnOrDigits(n, d) 
    BigNum n; 
    BigNumDigit d;
</pre>
<p>
  
<li><b>Inputs</b>
   
<OL type="1">
<p>
    
<li>    <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,1)</tt>.
    
<li>     <tt>D</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; digit <tt>d</tt>.
   </OL>
<p>
  
<li><b>Invariant</b>: let n<font face=symbol>Ú</font
>d be the bitwise logical <em>OR</em> of <tt>N</tt> and
D.
  
<li><b>Output</b>: none
  
<li><b>Side Effect</b>: n<font face=symbol>Ú</font
>d &nbsp;&nbsp;<font face=symbol>Þ</font
> <tt>(n,1)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnOrDigits</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>. 

<p>
   <b>Procedure 24</b> <em><tt> BnnXorDigits </tt>:
<a NAME="Bnn+XorDigits(n,d)37">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
void BnnXorDigits(n, d) 
    BigNum n; 
    BigNumDigit d;
</pre>
<p>
  
<li><b>Inputs</b>
   
<OL type="1">
<p>
    
<li>    <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,1)</tt>.
    
<li>     <tt>D</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; digit <tt>d</tt>.
   </OL>
<p>
  
<li><b>Invariant</b>: let n<font face=symbol>Å</font
>d be the bitwise <em>EXCLUSIVE-OR</em> 
of <tt>N</tt> and D.
  
<li><b>Output</b>: none
  
<li><b>Side Effect</b>: n<font face=symbol>Å</font
>d &nbsp;&nbsp;<font face=symbol>Þ</font
> <tt>(n,1)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnXorDigits</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>.   
 
<p>
      <H3><A NAME="tth_sEc3.8">
3.8</A>&nbsp;&nbsp;Assignments</H3>
The following functions permit direct manipulation of 
the  representation.

<p>
   <b>Procedure 25</b> <em><tt> BnnSetToZero </tt>:
<a NAME="Bnn+SetToZero(n,nl)38">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
void BnnSetToZero(n, nl)  
    BigNum n;  
    unsigned nl; 
</pre>
<p>
  
<li><b>Input</b>:
  
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ].
  
<li><b>Output</b>: none
  
<li><b>Side Effect</b>: 0 &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp; <tt>(n,nl)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnSetToZero</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; if <tt>nl</tt> = 0 then no side
effect is performed.
 
<p>

   <b>Procedure 26</b> <em><tt> BnnSetDigit </tt>:
<a NAME="Bnn+SetDigit(n,d)38">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
void BnnSetDigit(n, d) 
    BigNum n; 
    BigNumDigit d; 
</pre>
<p>
  
<li><b>Inputs</b>
   
<OL type="1">
<p>
    
<li>      <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,1)</tt>.
    
<li> <tt>d</tt> is an integer 0  <font face=symbol>£</font
> <tt>d</tt> <font face=symbol> &lt; </font
> <b>b</b>.
   </OL>
<p>
  
<li><b>Output</b>: none
  
<li><b>Side Effect</b>: <tt>d</tt> &nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp; <tt>(n,1)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnSetDigit</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>. 

<p>
   <b>Procedure 27</b> <em><tt> BnnAssign </tt>:
<a NAME="Bnn+Assign(m,n,nl)38">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
void BnnAssign(m, n, nl)  
    BigNum m, n;  
    unsigned nl; 
</pre>
<p>
  
<li><b>Inputs</b>
   
<OL type="1">
<p>
    
<li>    <tt>M</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(m,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[m<sub>0</sub> <font face=symbol>¼</font
>m<sub>nl-1</sub> ].
    
<li> 
<p>
   <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ].
   </OL>
<p>
  
<li><b>Output</b>: none
  
<li><b>Side Effect</b>: <tt>N</tt>&nbsp;&nbsp;<font face=symbol>Þ</font
> &nbsp;&nbsp; <tt>(m,nl)</tt>.
</UL>
<p>
</em>
Note: <tt> BnnAssign</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; all kinds of overlapping are
possible; no side effect when <tt>nl</tt> = 0.
 
<p>
      <H3><A NAME="tth_sEc3.9">
3.9</A>&nbsp;&nbsp;Conversion to a small integer</H3>
In most languages, it is not possible to represent, 
as the value of an ordinary integer, a full size (e.g., 32 bit) digit. 
The following predicate specifies which
digits can be directly represented by an integer in the target language.
The binary length of such numbers is less than the package constant:
<tt>BN_WORD_SIZE</tt>. (In LeLisp , <tt>BN_WORD_SIZE</tt>=15, for example).

<p>
   <b>Procedure 28</b> <em><tt>  BnnDoesDigitFitInWord  </tt>:
<a NAME="Bnn+DoesDigitFitInWord(d)39">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
Boolean BnnDoesDigitFitInWord(d) 
    BigNumDigit d; 
</pre>
<p>
  
<li><b>Input</b>:
      <tt>D</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp; digit <tt>d</tt>.
  
<li><b>Output</b>: the predicate log<sub>2</sub> (<tt>D</tt>)  <font face=symbol>£</font
>  <tt>BN_WORD_SIZE</tt>.
  
<li><b>Side Effect</b>: none.
</UL>
<p>
</em>
Note: <tt> BnnDoesDigitFitInWord</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>.

<p>
   <b>Procedure 29</b> <em><tt> BnnGetDigit </tt>:
<a NAME="Bnn+GetDigit(n)39">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigNumDigit BnnGetDigit(n)  
    BigNum n; 
</pre>
<p>
  
<li><b>Input</b>:
      <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,1)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;n<sub>0</sub>,
such that log<sub>2</sub>(n<sub>0</sub>)  <font face=symbol>£</font
>  <tt> BN_WORD_SIZE</tt>.
  
<li><b>Output</b>: the digit n<sub>0</sub> as a regular C unsigned  integer.
  
<li><b>Side Effect</b>: none
</UL>
<p>
</em>
Note: <tt> BnnGetDigit</tt>  <font face=symbol>Î</font
>  <tt>KerN</tt>; this function does not test
whether n<sub>0</sub> actually fits in a word.

<p>
      <H2><A NAME="tth_sEc4">
4</A>&nbsp;&nbsp;Storage allocating operations: Bz</H2>
The layer <tt>Bz</tt> is conceptually simpler than <tt>Bn</tt>. A number 
z  <font face=symbol>Î</font
> Z is represented by a pointer to an array containing the sign and the
digits of the base <b>b</b> representation of z. Procedures in <tt>Bz</tt>
allocate storage for their results.

<p>
      <H3><A NAME="tth_sEc4.1">
4.1</A>&nbsp;&nbsp;Initialization Operations</H3>

<p>

   <b>Procedure 30</b> <em>Initialization <tt> BzInit</tt>:
<a NAME="Bz+Init()41">
</a>

<UL>
<p>
 
<li> <b>C header</b>: 

<pre>
void BzInit()
</pre>
<p>
 
<li> <b>Inputs</b>: none 
 
<li> <b>Output</b>: none
 
<li> <b>Side Effect</b>: initializes Bz and Bn.
</UL>
<p>
</em>

   <b>Procedure 31</b> <em>Closing <tt> BzClose</tt>:
<a NAME="Bz+Close()41">
</a>

<UL>
<p>
 
<li> <b>C header</b>: 

<pre>
void BzClose()
</pre>
<p>
 
<li> <b>Inputs</b>: none 
 
<li> <b>Output</b>: none
 
<li> <b>Side Effect</b>: closes Bz and Bn.
</UL>
<p>
</em>
      <H3><A NAME="tth_sEc4.2">
4.2</A>&nbsp;&nbsp;Storage operations</H3>

<p>

   <b>Procedure 32</b> <em>Allocate  <tt>BzCreate</tt>:
<a NAME="Bz+Create(size)42">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzCreate (size)    
     unsigned size;
</pre>
<p>
  
<li><b>Output</b>: a number having <tt>size</tt> digits.
</UL>
<p>
</em>
 
   <b>Procedure 33</b> <em>Dispose  <tt>BzFree</tt>:
<a NAME="Bz+Free(z)42">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
void BzFree (z)
     BigZ z;
</pre>
<p>
  
<li><b>Output</b>: none
  
<li><b>Side Effect</b>: Frees the storage occupied by z.
</UL>
<p>
</em>
 
   <b>Procedure 34</b> <em>Physical copy  <tt>BzCopy</tt>:
<a NAME="Bz+Copy(z)42">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzCopy (z)
     BigZ z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzCopy(z)</tt>  = z .
</UL>
<p>
</em>

   <b>Procedure 35</b> <em>Size  <tt>BzNumDigits</tt>:
<a NAME="Bz+NumDigits(z)42">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
unsigned BzNumDigits (z)
     BigZ z;
</pre>
<p>
  
<li><b>Output</b>: the number of significant digits of z.
</UL>
<p>
</em>
 
   <b>Procedure 36</b> <em>Size  <tt>BzGetSize</tt>:
<a NAME="Bz+GetSize(z)42">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
unsigned BzGetSize (z)
     BigZ z;
</pre>
<p>
  
<li><b>Output</b>: the number of allocated digits of z.
</UL>
<p>
</em>
       <H3><A NAME="tth_sEc4.3">
4.3</A>&nbsp;&nbsp;Arithmetic Operations</H3>
 
<p>

   <b>Procedure 37</b> <em>Absolute value <tt>BzAbs</tt>
<a NAME="Bz+Abs(z)43">
</a>

<UL>
<p>
   
<li> <b>C header</b>: 

<pre>
BigZ BzAbs (z)  
     BigZ z;
</pre>
<p>
   
<li> <b>Output</b>: <tt>BzAbs(z)</tt> = <font face=symbol>|</font
>z<font face=symbol>|</font
> = sgn(z) &times;z.
</UL>
<p>
</em>
 
   <b>Procedure 38</b> <em>Sign  <tt>BzGetSign</tt>:
<a NAME="Bz+GetSign(z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigNumCmp BzGetSign (z) 
     BigZ z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzGetSign(z)</tt>  = sgn(z) = { -1,0,1 }.
</UL>
<p>
</em>
  
   <b>Procedure 39</b> <em>Arithmetic opposite  <tt>BzNegate</tt>:
<a NAME="Bz+Negate(z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzNegate (z)       
     BigZ z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzNegate(z)</tt>  = -z .
</UL>
<p>
</em>
  
   <b>Procedure 40</b> <em>Comparison  <tt>BzCompare</tt>:
<a NAME="Bz+Compare(y,z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigNumCmp BzCompare (y, z)
     BigZ y, z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzCompare(y,z)</tt>  = sgn(y-z) = { -1,0,1 }.
</UL>
<p>
</em>
  
   <b>Procedure 41</b> <em>Addition  <tt>BzAdd</tt>:
<a NAME="Bz+Add(y,z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzAdd (y, z)       
     BigZ y, z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzAdd(y,z)</tt>  = y+z .
</UL>
<p>
</em>
  
   <b>Procedure 42</b> <em>Subtraction <tt>BzSubtract</tt>:
<a NAME="Bz+Subtract(y,z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzSubtract (y, z)  
     BigZ y, z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzSubtract(y,z)</tt>  = y-z .
</UL>
<p>
</em>
  
   <b>Procedure 43</b> <em>Multiplication  <tt>BzMultiply</tt>:
<a NAME="Bz+Multiply(y,z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzMultiply (y, z)
     BigZ y, z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzMultiply(y,z)</tt>  = y &times;z .
</UL>
<p>
</em>
  
   <b>Procedure 44</b> <em>Quotient  <tt>BzDiv</tt>:
<a NAME="Bz+Div(y,z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzDiv (y, z)
     BigZ y, z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzDiv(y,z)</tt>  = y <font face=symbol>¸</font
>z .
</UL>
<p>
</em>
  
   <b>Procedure 45</b> <em>Modulo  <tt>BzMod</tt>:
<a NAME="Bz+Mod(y,z)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzMod (y, z)
     BigZ y, z;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzMod(y,z)</tt>  = y  mod z .
</UL>
<p>
</em>
 
   <b>Procedure 46</b> <em>Division  <tt>BzDivide </tt>:
<a NAME="Bz+Divide(y,z,r)43">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzDivide (y, z, r)
     BigZ y, z, *r;
</pre>
<p>
  
<li><b>Output</b>: the quotient y <font face=symbol>¸</font
>z.
  
<li><b>Side Effect</b>: assigns the modulo to  r.
</UL>
<p>
</em>
       <H3><A NAME="tth_sEc4.4">
4.4</A>&nbsp;&nbsp;Read and Print</H3>
 
<p>

   <b>Procedure 47</b> <em>Write in base b  <tt>BzToString</tt>:
<a NAME="Bz+ToString(z,b)44">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
char* BzToString (z, b)
     BigZ z;
     unsigned b;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzToString(z,b)</tt> is the string representing
z in base b, with 2  <font face=symbol>£</font
> b  <font face=symbol>£</font
> 16.
</UL>
<p>
</em>
 
   <b>Procedure 48</b> <em>Read in base b  <tt>BzFromString</tt>:
<a NAME="Bz+FromString(s,b)44">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzFromString (s, b)
     char *s;
     unsigned b;
</pre>
<p>
  
<li><b>Output</b>: <tt>BzFromString(s,b)</tt> is the number represented
by the string s, in base b with 2  <font face=symbol>£</font
> b  <font face=symbol>£</font
> 16, .
</UL>
<p>
</em>
      <H3><A NAME="tth_sEc4.5">
4.5</A>&nbsp;&nbsp;Conversions</H3>

<p>

   <b>Procedure 49</b> <em><tt>BzFromInteger</tt>:
<a NAME="Bz+FromInteger(i)45">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzFromInteger (i)    
     int i;
</pre>
<p>
  
<li><b>Output</b>: a number equal to <tt>i</tt>.
</UL>
<p>
</em>

   <b>Procedure 50</b> <em><tt>BzToInteger</tt>:
<a NAME="Bz+ToInteger(z)45">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
int BzToInteger (z)    
     BigZ z;
</pre>
<p>
  
<li><b>Output</b>: an integer equal to <tt>z</tt> 
   iff <tt>-MAXINT</tt> <font face=symbol> &lt; </font
> <tt>z</tt>  <font face=symbol>£</font
>  <tt>MAXINT</tt>,
                    otherwise returns <tt>-MAXINT</tt>.
</UL>
<p>
</em>

   <b>Procedure 51</b> <em><tt>BzFromBigNum</tt>:
<a NAME="Bz+FromBigNum(n,nl)45">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigZ BzFromBigNum (n, nl)    
     BigNum n;
     unsigned nl;
</pre>
<p>
 
<li> <b>Inputs</b>: 
     
<p>
 <tt>N</tt>&nbsp;&nbsp; <font face=symbol>º</font
> &nbsp;&nbsp;<tt>(n,nl)</tt>  <font face=symbol>º</font
> &nbsp;&nbsp;&nbsp;<sub>b</sub>[n<sub>0</sub> <font face=symbol>¼</font
>n<sub>nl-1</sub> ].
 
<li><b>Output</b>: a number equal to <tt>N</tt>.
</UL>
<p>
</em>

   <b>Procedure 52</b> <em><tt>BzToBigNum</tt>:
<a NAME="Bz+ToBigNum(z,nl)45">
</a>

<UL>
<p>
  
<li><b>C header</b>:

<pre>
BigNum BzToBigNum (z, nl)    
     BigZ z;
     unsigned * nl;
</pre>
<p>
  
<li><b>Output</b>: a number <tt>N</tt> equal to <tt>z</tt> iff <tt>z</tt>  <font face=symbol>³</font
> 0 ,
                    otherwise returns NULL.
  
<li><b>Side Effect</b>: assigns the length of <tt>N</tt> to <tt>nl</tt>.

<p>
</UL></em>
       <H2><A NAME="tth_sEc5">
5</A>&nbsp;&nbsp;Bibliography</H2>

<DL compact>
<p>
<dt><b>[Knuth</b></dt><dd>]
D. E. Knuth,

<p>
The Art of Computer Programming, vol. 2, Seminumerical Algorithms.

<p>
Addison Wesley, 1981.
</DL>
<p>
      <H2><A NAME="tth_sEcA">
A</A>&nbsp;&nbsp;What is in the package?</H2>

<pre>
   Documentation Files:
      doc/bn.tex      - This document in LaTeX format
      doc/bnf.tex     - Document BigNum in French and LaTeX format

   C Include Files:
      h/BigZ.h        - Types and structures for clients of BigZ
      h/BigNum.h      - Types and structures for clients of BigNum

   C Source Code:
      c/bz.c          - BigZ implementation
      c/bn.c          - BigNum implementation ("non-kernel" routines)
      c/KerN.c        - BigNum implementation ("kernel" routines)
      c/bztest.c      - Test program for verifying BigZ implementation
      c/testKerN.c    - Test program for verifying KerN implementation

   Assembly-Language Source Code:
      s/vaxKerN.s     - VAX implementation of KerN
      s/68KerN.s      - 68020 implementation of KerN (MIT syntax)
      s/68KerN.mot.s  - 68020 implementation of KerN (Motorola syntax)
      s/nsKerN.s      - NS implementation of KerN

   Other Files:
      Makefile        - Compiles source code, creates test programs

In order to build or modify the current version of the package, 
the following commands are provided:
      make vax        - to use vax assembly code
      make 68K        - to use 68020 assembly code
      make ns         - to use NS assembly code
      make C16        - to use C code with 16 bit digits
      make C32        - to use C code with 32 bit digits 
      make            - to use the default version (C32)

One of these commands products the following files:
      BigNum.a        - BigNum library
      bztest          - Test program executable for BigZ
      testKerN        - Test program executable for KerN

If you have the tools LaTeX, makeindex and aptex, type:
      make doc        - to build the Postscript files of the documents
</pre>
<p>
      <H2><A NAME="tth_sEcB">
B</A>&nbsp;&nbsp;How to obtain the package?</H2>
<A NAME="HowToObtain">
</A>
This document and the source code of the BigNum package bear the
marking "Copyright Digital Equipment Corporation &amp; INRIA 1989"
This documentation and the source code of the BigNum package may
be ordered either by postal or electronic mail from:<br>

<p>
    Digital PRL<br>			
    85, Avenue Victor Hugo<br> 
    92563 Rueil Malmaison Cedex  France<br>         
    (librarian@decprl.dec.com) <br>

<p>
 or INRIA<br>			
    Bernard Serpette<br>
    Domaine de Voluceau<br> 
    78150 Rocquencourt  France<br>
    (serpette@inria.inria.fr)<br>

<p>
  The source code will be sent through electronic mail.

<p>
This documentation, and the source code of the BigNum package may
be reproduced and distributed freely provided that the following
conditions are respected:

<UL>
<p>
   
<li> Digital PRL or INRIA should be notified of the copy.

<p>
   
<li> The original Copyright notice should not be removed from the
   documentation or from the source code under any circumstances.
 
<p>
   
<li> Any work using the BigNum package should state explicitly the use
   of such package, and its origin by including the following sentence:
   <em>This work uses the BigNum package developed jointly by INRIA and
   Digital PRL.</em>

<p>
   
<li> If any modification is applied to the BigNum package,
   explicit statements should identify the fact that such modifications
   have been made, by whom, and where. These statements should not be
   removed in any further distribution.
 
<p>
   
<li> Any work using extensively the BigNum package should be freely
   distributed under conditions similar to the distribution of the
   BigNum package.
</UL>
<p>
INRIA and Digital Equipment Corporation make no representations, 
express or implicit, with
respect to this documentation or the software it describes, including
without limitations, any implied warranties of merchandability or
fitness for a particular purpose, all of which are expressly
disclaimed. INRIA and Digital Equipment Corporation  or subsequent distributors 
shall in no event
be liable for any indirect, incidental or consequential damages.

<p>
<br>We are thankfull to the following people, for their contributions
to this package:
Patrice Bertin, Hans Boehm, Jerome Chailloux, Michel Gangnet, 
Fran&#231;ois Morain, David Salesin and Mark Shand.

<p>
 <a name="tth_sEcindex"></a>

<H2> Index (showing section)</H2>
<hr><H3>Footnotes:</H3>

<p><a name=tthFtNtAAD></a><a href="#tthFrefAAD"><sup>3</sup></a> LeLisp is a registered
trade-mark of INRIA.
<p><hr><small>File translated from T<sub><font size="-1">E</font></sub>X by <a href="http://hutchinson.belmont.ma.us/tth/">T<sub><font size="-1">T</font></sub>H</a>, version 1.57.</small>
</HTML>
